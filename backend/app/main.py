from fastapi import FastAPI, UploadFile, File, Form
from fastapi.middleware.cors import CORSMiddleware
from pydantic import BaseModel
from typing import Optional, List

from .utils import extract_text_from_bytes
from .skill_builder import build_role_skills
from .skill_store import get_role_skills
from .nlp import (
    extract_skills_from_text,
    score_match,
    build_skill_targets_for_role_and_jd,
)


app = FastAPI(title="Resumeâ€“Job Matcher API (Role + JD + LLM Skills)")


# -----------------------------------------------------
# CORS (for your React frontend)
# -----------------------------------------------------
app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],  # Restrict in production
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)


# -----------------------------------------------------
# Health Check
# -----------------------------------------------------
@app.get("/")
def home():
    return {
        "status": "backend running",
        "engine": "role + JD + LLM skill-based",
    }


# -----------------------------------------------------
# Response Models
# -----------------------------------------------------
class MatchResponse(BaseModel):
    match_score: float
    matched_keywords: List[str]
    missing_keywords: List[str]
    extra_keywords_in_resume: List[str]
    total_jd_keywords: int
    total_resume_keywords: int
    jd_keywords: List[str]
    resume_keywords: List[str]
    role_skills: List[str]
    jd_explicit_skills: List[str]


class GenerateSkillsResponse(BaseModel):
    role: str
    skills: List[str]


# -----------------------------------------------------
# Admin / Setup: Generate skills for a role using LLM
# -----------------------------------------------------
@app.post("/api/generate-skills", response_model=GenerateSkillsResponse)
def generate_skills(role: str = Form(...)):
    """
    Call once per role (e.g., "Software Engineer", "Database Administrator").
    This uses an LLM to generate skills and saves them into skills_db.json.
    """
    skills = build_role_skills(role)
    return GenerateSkillsResponse(role=role, skills=skills)


# -----------------------------------------------------
# Main Match API: Resume + JD + Role
# -----------------------------------------------------
@app.post("/api/match", response_model=MatchResponse)
async def match_resume(
    resume: UploadFile = File(...),
    job_description: str = Form(...),
    role: str = Form(...),
):
    """
    Inputs:
    - resume: file upload (PDF/TXT)
    - job_description: raw text
    - role: e.g., "Software Engineer", "Database Administrator", etc.

    Flow:
    - Load skills for the role (from skills_db.json, pre-generated by LLM).
    - Extract which of those skills are explicitly mentioned in the JD.
    - Combine role skills + JD explicit skills as the target set.
    - Extract skills from the resume (within the same skill universe).
    - Compute match score + missing + extra.
    """

    # 1) Extract resume text
    resume_bytes = await resume.read()
    resume_text = extract_text_from_bytes(resume_bytes, resume.filename)

    # 2) Build target skills from role + JD
    skill_targets = build_skill_targets_for_role_and_jd(role, job_description)
    target_skills = skill_targets["combined_skills"]
    role_skills = skill_targets["role_skills"]
    jd_skills = skill_targets["jd_skills"]

    # 3) Extract resume skills (using the same target universe)
    resume_skills = extract_skills_from_text(resume_text, candidate_skills=target_skills)

    # 4) Score the match
    result = score_match(target_skills, resume_skills)

    return MatchResponse(
        **result,
        jd_keywords=target_skills,
        resume_keywords=sorted(resume_skills),
        role_skills=role_skills,
        jd_explicit_skills=jd_skills,
    )
